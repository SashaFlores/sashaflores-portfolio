<!DOCTYPE html>
<html lang="en">

<head>
    <!-- meta tags -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">

    <title>Optimization of Gas and Bytecode Limitation</title>
    <meta name="keywords"
        content="bytecode size limitation, ethereum, solidity, smart-contracts, blockchain, gas optimization, exceeds contract size, might not be deployable on mainnet">
    <meta name="author" content="Sasha Flores">
    <meta property="og:type" content="website">

    <!-- Bootstrap CSS -->
    <link href="../../css/bootstrap.min.css" rel="stylesheet">
    <link href="../../css/aos.css" rel="stylesheet">
    <link href="../../css/navbar.css" rel="stylesheet">
    <link href="../../css/articles-common.css" rel="stylesheet">
    <link href="../../css/footer.css" rel="stylesheet">


    <script async src="https://www.googletagmanager.com/gtag/js?id=G-MXTX916K7T"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-MXTX916K7T');
    </script>
</head>

<body class="page-offset">
    <i class="bi bi-list mobile-nav-toggle d-xl-none"></i>
    <header>
        <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
            <div class="container-fluid px-md-5">
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse"
                    data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent"
                    aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <div class="collapse navbar-collapse" id="navbarSupportedContent">
                    <ul class="navbar-nav me-auto mb-2 mb-lg-0" data-aos="fade-down" data-aos-duration="1000">
                        <li class="nav-item">
                            <a class="nav-link" aria-current="page" href="../../index.html">HOME</a>
                        </li>

                        <li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href="#" id="aboutDropdown"
                                role="button" data-bs-toggle="dropdown" aria-expanded="false">ABOUT ME</a>
                            <ul class="dropdown-menu" aria-labelledby="aboutDropdown">
                                <li><a class="dropdown-item" href="../../background.html">Background</a></li>
                                <li><a class="dropdown-item" href="../../skills.html">Skills</a></li>
                                <li><a class="dropdown-item" href="../../experience.html">Experience</a></li>
                            </ul>
                        </li>
                        <li class="nav-item"><a class="nav-link" href="../../portfolio.html">PORTFOLIO</a></li>
                        <li class="nav-item"> <a class="nav-link active" href="../../blog.html">BLOG</a></li>
                        <li class="nav-item"><a class="nav-link" href="../../contact.html">CONTACT</a></li>
                    </ul>

                    <div class="nav-cta">
                        <button type="button" class="nav-cta__btn" data-connect-trigger aria-haspopup="dialog" aria-controls="walletModal">CONNECT</button>
                        <button type="button" class="nav-cta__btn nav-cta__btn--accent" data-subscribe-trigger aria-haspopup="dialog" aria-controls="subscribeModal">SUBSCRIBE</button>
                    </div>
                </div>
            </div>
        </nav>
    </header>
    <div class="article-container">
        <h1 id="title">Optimization of Gas and Bytecode Limitation</h1>
        <figure class="meta">
            <img alt="Ethereum" src="https://miro.medium.com/1*zgsFrtE0dg3nqaNzX-H_MQ.jpeg" />
        </figure>
        <div class="article-stats" data-post-id="gas-bytecode-optimization">
            <button type="button" class="stat" data-role="like">
                <ion-icon name="thumbs-up-outline"></ion-icon>
                <span class="stat-number">0</span>
            </button>
            <div class="stat stat-view">
                <ion-icon name="eye-outline"></ion-icon>
                <span class="stat-number">0</span>
            </div>
        </div>
        <p>
            Solidity is a curly-bracket language influenced by C++, Python, & JavaScript; yet coding in solidity is
            different
            from any other language as every piece of code cost you gas. it is is designed to target the EVM, so before
            we dig into the tips & tricks of saving gas & reducing bytecode size,
            we will have a quick overview of six areas where data is stored in the EVM:
        </p>
        <p><i>STORAGE</i></p>
        <ul>
            <li>Storage is a key-value store that maps 32-byte words to 32-byte words.</li>
            <li>It is expensive to read from and write to storage.</li>
            <li>It is persistent between function calls and transactions and is the most expensive data location.</li>
            <li>each storage slot is 32 bytes in size.</li>
            <li><code>SSTORE</code> opcode will cost 20,000 gas units to store a value, which will vary based on the
                opcode arguments.</li>
            <li><code>SLOAD</code> opcode will cost 800 gas units to read from storage, which will vary based on the
                opcode arguments.</li>
        </ul>
        <p><i>MEMORY</i></p>
        <ul>
            <li>Memory is a byte array that is ephemeral and non-persistent between function calls.</li>
            <li>is relatively cheap to write & read to memory, but have to consider the expansion cost when writing to
                memory, as explained below.</li>
            <li>is linear and can be addressed at byte level, but reads are limited to a width of 256 bits, while writes
                can be either 8 bits or 256 bits wide.</li>
            <li><code>MLOAD, MSTORE, MSTORE8</code> opcode have a base cost of 3 gas units.</li>
            <li>Each additional 32 bytes will cost 3 gas units.</li>
        </ul>
        <p><i>STACK</i></p>
        <ul>
            <li>EVM isn't a register machine but a stack machine where all computations are performed on a data area
                called the stack.</li>
            <li>Stack is a last-in-first-out data structure that is ephemeral and non-persistent between function calls.
            </li>
            <li>is the cheapest data location to read from and write to.</li>
            <li>It has a maximum size of 1024 stack slots and maintains a stack of uint256s used to hold local
                variables, function call arguments and return addresses.</li>
            <li>opcodes to push, duplicate, & swap have a base cost of 3 gas units, which may vary based on opcode
                arguments, while pop has cost of 2 gas units:</li>
            <code>PUSH, POP, SWAP, DUP</code> opcode have a base cost of 3 gas units.
            <br><code>DUP</code> to clone from the last value to the last to the 16th last value on the stack.
            <br><code>SWAP</code> to swap from the last 2 values to the top of the stack within the 17th last element.
            <br><code>POP</code> removes a uint256 off the stack and discards it.
        </ul>
        <p><i>CALL DATA</i></p>
        <ul>
            <li>Call data is a non-modifiable, non-persistent area where function arguments are stored, and behaves
                mostly like memory.</li>
            <li>It usually contains a 4-byte method identifier followed by serialized arguments.</li>
            <li>It is read-only and mainly used to retrieve information or parameters supplied by external callers.</li>
            <li>reading from calldata is less expensive than reading from memory.</li>
            <li><code>CALLDATASIZE</code> opcode will cost 2 gas units, which will vary based on the data size
                retrieved.</li>
            <li><code>CALLDATALOAD & CALLDATACOPY</code> opcode will cost 3 gas units to read from call data, which will
                vary based on the opcode arguments.</li>
        </ul>
        <p><i>CODE</i></p>
        <ul>
            <li>is the bytecode of your smart contract limited to 2457 6bytes.</li>
        </ul>
        <p><i>LOGS</i></p>
        <ul>
            <li>Logs are a special data location that is non-persistent and non-modifiable.</li>
            <li>It is the mechanism for recording and storing events or data in a decentralized and immutable manner.
            </li>
            <li>They are included as part of the transaction receipt, which is generated when a transaction is
                successfully executed on the blockchain.</li>
            <li>Logs are considerably cheap but still accumulating events, especially with indexed values will
                accumulate gas.</li>
        </ul>

        <h3 class="article-item">Solidity tips and tricks to save gas and reduce bytecode size:</h3>

        <p><b>1 - State Variables</b></p>
        <ul>
            <li><b>You can pack as many state variables in one slot as long as it fits 32 bytes.</b></li>
            <pre class="code-block">
                <code class="language-solidity">
                    // poor code example
                    address public sender;  // slot 1: 20 bytes
                    uint256 private count;  // slot 2: 32 bytes
                    uint96 private value;  // slot 3: 12 bytes
                    bytes32 private name;  // slot 4: 32 bytes
                </code>
            </pre>
            <p>
                The code snippet above is a poor code because it didn't fully utilize each storage slot & used more
                than the number of slots needed for the state variables, instead you can pack your variables as follows:
            </p>
            <pre class="code-block">
                <code class="language-solidity">
                    // good code example
                    address public sender;  // slot 1: 20 bytes
                    uint96 private value;  // slot 1: 12 bytes
                    uint256 private count;  // slot 2: 32 bytes
                    bytes32 private name;  // slot 3: 32 bytes
                </code>
            </pre>
            <li><b>Reconsider type & size of state variable.</b></li>
            <pre class="code-block">
                <code class="language-solidity">
                    // poor code example
                    uint256 public amount;  // slot 1: 32 bytes
                    string private name;    // slot variable: depends on the string length
                    bytes private identifier;  // slot variable: depends size of bytes
                </code>
            </pre>
            <p>The code snippet above can be considered poor code because:</p>
            <p><i>- you can use uint96 instead of uint256: 2 ^96–1 = 79,228,162,514,264,337,593,543,950,335</i></p>
            <p><i>- if you are certain that your data can fit into bytes 32, then it's way cheaper to use bytes 32
                    instead of strings & bytes. </i></p>
            <p><i>- generally speaking, fixed size data is cheaper than dynamic data.</i></p>
            <p><i>- to calculate the storage size of a string in bytes, you can use the following formula: Size in bytes
                    = (string length * 32) + 32.</i></p>
            <p><i>- let's say you have a string of 10 characters, then the storage size would be: (10 * 32) + 32 =
                    352.</i></p>
            <pre class="code-block">
                <code class="language-solidity">
                    /// good code example
                    uint96 public amount;  // slot 1: 12 bytes
                    bytes20 private name;  // slot 1: 20 bytes
                    bytes32 private identifier;  // slot 2:32 bytes
                </code>
            </pre>
            <li><b>Consider constant & immutable variables if their state wouldn't change during the lifetime of a smart
                    contract.</b></li><br>

            <p>The compiler does not reserve a storage slot for these variables, and every occurrence is replaced by its
                respective value.</p>

            <p><b><i>For constant variables:</i></b></p>
            <p>- The value has to be fixed at compile-time.</p>
            <p>
                - Disallowed any expression that accesses storage, blockchain data (e.g., <code>block.timestamp</code>,
                <code>address(this).balance</code> or <code>block.number</code>), <br>or execution data
                (<code>msg.value</code>
                or <code>gasleft()</code>), or makes calls to external contracts.
            </p>
            <p><b><i>For immutable variables:</i></b></p>
            <p>- It can still be assigned at construction time.</p>
            <p>
                - The contract creation code generated by the compiler will modify the contract's runtime code before it
                is returned by
                replacing all references to immutable with the values assigned to them. This is important if you are
                comparing the
                runtime code generated by the compiler with the one actually stored in the blockchain.
            </p>

            <blockquote style="margin: 20px; padding-left: 10px; border-left: 5px solid #c4d59a;">
                <p>In some cases, constant values can be cheaper than immutable values as the EVM reserve 32 bytes for
                    immutable regardless if they can fit in fewer bytes.</p>
            </blockquote>

            <li><b>Don't initialize variables with their default value.</b></li><br>
            <p>If you're declaring a state variable with their prospective default value, you're wasting gas and will be
                considered a poor code, the default values for different types are as follows:</p>

            <p><b><i>Boolean:</i></b></p>
            <p>- The default value for a boolean variable is <code>false</code>.</p>
            <p>- If a boolean variable is declared without initialization, it will have the default value of
                <code>false</code>.</p>

            <p><b><i>Unsigned Integer:</i></b></p>
            <p>- The default value for is <code>uint</code> is <code>0</code>.</p>
            <p>- If a uint variable is declared without initialization, it will have the default value of
                <code>0</code>.</p>
            <p>- The default value for other unsigned integer types, like <code>uint8</code>, <code>uint16</code>, etc.,
                follows the same rule and is <code>0</code>.</p>

            <p><b><i>Bytes:</i></b></p>
            <p>- The default value for a bytes variable is an empty byte array, represented by <code>0x</code> (a
                hexadecimal value indicating an empty byte array).</p>
            <p>- If a bytes variable is declared without initialization, it will have the default value of an empty byte
                array.</p>

            <li><b>Minimize touching the storage.</b></li><br>
            <p>
                Try to minimize reading from and writing to storage as much as you can, we all know the value of a state
                variable can
                change in the scoop of any function. If it is necessary to iterate over or modify a variable, consider
                the following example:
            </p>
            <pre class="code-block">
                <code class="language-solidity">
                    contract PoorExampleContract {
                        uint256[] public dataArray;
                        uint256 public index;
                    
                        function updateDataArray(uint256 newValue) public {
                            // 1st storage touch
                            require(index < dataArray.length, "Index out of bounds");
                            // 2nd storage touch
                            if (index == 0) {
                                dataArray[0] = newValue;
                            } else {
                                for (uint256 i = 1; i < dataArray.length; i++) {
                                    if (i == index) {  // 3rd storage touch
                                        dataArray[i] = newValue;
                                    }
                                }
                            }
                        }
                    }
                </code>
            </pre>
            <pre class="code-block">
                <code class="language-solidity">
                    contract GoodExampleContract {
                        uint256[] public dataArray;
                        uint256 public index;
                    
                        function updateDataArray(uint256 newValue) public {
                            // 1st storage touch
                            uint256 tempIndex = index;
                            require(tempIndex < dataArray.length, "Index out of bounds");
                            
                            if (tempIndex == 0) {
                                dataArray[0] = newValue;
                            } else {
                                uint256 currentValue = dataArray[tempIndex];
                                if (currentValue != newValue) {
                                    dataArray[tempIndex] = newValue;
                                }
                            }
                            // 2nd storage touch
                            index = tempIndex;
                        }
                    }
                </code>
            </pre>
            <blockquote style="margin: 20px; padding-left: 10px; border-left: 5px solid #c4d59a;">
                <p>
                    Remember, it's important to handle memory variables properly to avoid potential issues like
                    exceeding the available
                    memory or running out of gas due to excessive memory usage.
                </p>
            </blockquote>
        </ul>
        <br>
        <p><b>2- Memory</b></p><br>
        <p>
            While memory considered cheaper compared to storage, it is expanded by a word (256-bit), when accessing
            (either reading or writing) a previously untouched memory word (i.e., any offset within a word). At the time
            of expansion, the cost in gas must be paid. Memory is more costly the larger it grows (it scales quadratically).
        </p>

        <img alt="Memory Expansion Gas Cost" src="https://miro.medium.com/1*SIUHDodEb4si2ex80mgsSw.png" />
        <p>
            <code>calldata</code> is an appealing and cheaper alternative to memory,
            <a href="https://eips.ethereum.org/EIPS/eip-2028#simple-summary">EIP-2028</a>
            reduced gas per non-zero byte from <b>68 gas per byte to 16 gas per byte</b>. Depending on how you
            want to handle and access the data within a function. Here's a guideline on when to use each type:
        </p>
        <ul>
            <li><b>Calldata:</b></li>
            <p>- Calldata is read-only, meaning you cannot modify its contents within the function.</p>
            <p>- It is useful when you want to minimize gas costs by avoiding unnecessary data copying.</p>
            <p>- Use <code>calldata</code> for input parameters, especially when you want to access data sent to your contract from an external source, such as another contract or an external account.</p>

            <li><b>Memory:</b></li>
            <p>- Memory is a temporary data storage area that is cleared between (external) function calls and is cheaper than storage.</p>
            <p>- When you need to modify or store data within the function, especially for temporary variables or data manipulation.</p>
            <p>- If you want to store a copy of <code>calldata</code> for later use within the function, you can assign it to a <code>memory</code> variable.</p>
        </ul>
        <pre class="code-block">
            <code class="language-solidity">
                contract ExampleContract{
                    function processData(uint256[] calldata data) public {
                        // Read-only access to calldata
                        uint256 sum = 0;
                        for (uint256 i = 0; i < data.length; i++) {
                            sum += data[i];
                        }
                
                        // Modify data using memory
                        modifyDataInMemory(data);
                    }
                
                    function modifyDataInMemory(uint256[] memory data) internal {
                        // Modify data in memory
                        for (uint256 i = 0; i < data.length; i++) {
                            data[i] = data[i] * 2;
                        }
                    }
                }
            </code>
        </pre>
        <blockquote style="margin: 20px; padding-left: 10px; border-left: 5px solid #c4d59a;">
            <p>
                By choosing the appropriate type (<code>calldata</code> or <code>memory</code>), 
                you can optimize gas costs and efficiently handle data based on your specific requirements 
                within your Solidity functions.
            </p>
        </blockquote>
        <br>
        <p><b>3- Pack & Hash Struct</b></p><br>
        <p>
            If you have a struct in your code that will eventually need to be set, modified, or read from in any function, 
            you can hash and store the struct
        </p>
        <pre class="code-block">
            <code class="language-solidity">
                contract PoorExampleContract {

                    struct Employee {
                        uint256 id;  // slot 1 storage
                        string name;  // complicated depending on string length
                        uint256 salary;  // full slot N after string
                    }
                
                    mapping(uint256 => Employee) public employees;
                
                    function addEmployee(uint256 _id, string calldata _name, uint256 _salary) public {
                        employees[_id] = Employee(_id, _name, _salary);
                    }
                
                    function updateSalary(uint256 _id, uint256 _newSalary) public {
                        Employee storage emp = employees[_id];
                        require(emp.id != 0, "Employee does not exist");
                
                        emp.salary = _newSalary;
                    }
                }
            </code> 
        </pre>
        <p>
            Each time an employee's data is modified, the entire struct is updated in storage, which can 
            lead to higher gas costs if the struct size is large or if frequent modifications are made.
        </p>
        <pre class="code-block">
            <code class="language-solidity">
                contract GoodExampleContract{

                    struct Employee {
                        uint15 id;  // slot 1 storage
                        uint17 salary;  // slot 1 storage
                        bytes32 firstName;  // slot 2 storage
                        bytes32 lastName;  // slot 3 storage
                    }
                
                    mapping(uint256 => bytes32) public hashedEmployees;
                    mapping(uint15 => Employee) public employees;
                
                    function addEmployee(Employee calldata _employee) public {
                        bytes32 hash = hashEmployee(_employee);
                
                        employees[_employee.id] = _employee;
                        hashedEmployees[_employee.id] = hash;
                    }
                
                    function updateSalary(uint15 _id, uint17 _newSalary) public {
                        Employee storage emp = employees[_id];
                        require(emp.id != 0, "Employee does not exist");
                
                        bytes32 oldHash = hashedEmployees[_id];
                        bytes32 newHash = updateHash(oldHash, emp.salary, _newSalary);
                
                        emp.salary = _newSalary;
                        hashedEmployees[_id] = newHash;
                    }
                
                    function hashEmployee(Employee memory _employee) internal pure returns (bytes32) {
                        return keccak256(abi.encode(_employee));
                    }
                
                    function updateHash(bytes32 _oldHash, uint17 _oldValue, uint17 _newValue) internal pure returns (bytes32) {
                        return keccak256(abi.encodePacked(_oldHash, _oldValue, _newValue));
                    }
                }
            </code>
        </pre>
        <p>
            — By accepting the struct as input in the <code>addEmployee</code> and <code>updateSalary</code> functions, 
            we improve gas efficiency by avoiding unnecessary data copying or parameter conversions. This can lead to 
            lower gas costs when interacting with the contract.
        </p>
        <p>
            — Employing hashing techniques, can help reduce gas costs by storing compact representations of 
                struct data and perform data integrity checks efficiently.
        </p>
        <p>
            — Using <code>calldata</code> option in the <code>addEmployee</code>improves gas efficiency by avoiding unnecessary data copying.
        </p>
        <p>
            — Using bytes32 for first & last name is more gas efficient than strings and bytes, but may have limitations in terms of length and flexibility.
        </p>
        <p>
            — Using uint15 for employee id will provide you with a max value of 32,768 which depends on the company size.
        </p>
        <p>
            — Using uint17 for salary will provide you with max value of 131,072 per month, which depends on the company payroll.
        </p>
        <br>

        <p><b>4- Use Assembly instead of Solidity</b></p><br>
        <p>
            Assembly is a low-level programming language that is converted to machine code using an 
            <a href="https://techterms.com/definition/assembler">assembler</a>. 
            The EVM has its own instruction set which is abstracted by Solidity, its high level language 
            for writing smart contract.
        </p>

        <pre class="code-block">
            <code class="language-solidity">
                contract AssemblyContract {

                    address private _owner;
                
                    
                    // 22710 gas
                    function transferOwnership(address owner) public {
                        _owner = owner;
                    }
                
                    // 2706 gas
                    function transferOwnershipAssembly(address owner) public {
                        assembly {
                            sstore(_owner.slot, owner)
                        }
                    }
                
                    // 405 gas
                    function balance() public view returns (uint256) {
                    return address(this).balance;
                    }
                
                    // 181 gas
                    function balanceAssembly() public view returns (uint256) {
                        assembly {
                            let c := selfbalance()
                            mstore(0x00, c)
                            return(0x00, 0x20)
                        }
                    }
                
                    receive() external payable {}
                
                
                    // 490 gas
                    function checkZeroAdd(address _address) public pure {
                        require(_address != address(0), 'ZeroAddress');
                    }
                
                    // 473 gas
                    function checkZeroAddAssembly(address _address) public pure {
                        assembly {
                            if iszero(_address) {
                                mstore(0x00, "zero address")
                                revert(0x00, 0x20)
                            }
                        }
                    }
                
                    // 1068 gas
                    function hashInput(uint256 amount, uint256 value) public pure {
                        keccak256(abi.encodePacked(amount, value));
                    }
                
                    // 691 gas
                    function hashInputAssembly(uint256 amount, uint256 value) public pure {
                        assembly {
                            mstore(0x00, amount)
                            mstore(0x20, value)
                            let hashedInputs := keccak256(0x00, 0x40)
                        }
                    }
                
                }
            </code>
        </pre>

        <blockquote style="margin: 20px; padding-left: 10px; border-left: 5px solid #c4d59a;">
            <p>
                The trade-off lies between complexity and gas efficiency. Inline assembly code can be more intricate to work with, 
                but it offers improved gas efficiency. However, utilizing inline assembly requires knowledge of EVM opcodes.
            </p>
        </blockquote>
        <br>

        <p><b>5- Time of Deployment and init function</b></p><br>

        <p>You can trade-off more cost during deployment than for execution of other functions, as shown below in the heatmap 
            of gas prices at various of the day gas cost changed dramatically due to network congestion; hence you can deploy your 
            contract for a gas price 5x or 10x less than other times.
        </p>
        <img alt="Source: intotheblock" src="https://miro.medium.com/1*VDkjPzMtndj2gOgOCWxYxw.png" />
        
        <p>Another great possibility is to do more in the init function to help reduce the gas needed at other times.</p>

        <pre class="code-block">
            <code class="language-solidity">
                // source: NFTX Protocol
                function __NFTXVault_init(
                        string memory _name,
                        string memory _symbol,
                        address _assetAddress,
                        bool _is1155,
                        bool _allowAllItems
                    ) public override virtual initializer {
                        __Ownable_init();
                        __ERC20_init(_name, _symbol);
                        require(_assetAddress != address(0), "Asset != address(0)");
                        assetAddress = _assetAddress;
                        vaultFactory = INFTXVaultFactory(msg.sender);
                        vaultId = vaultFactory.numVaults();
                        is1155 = _is1155;
                        allowAllItems = _allowAllItems;
                        emit VaultInit(vaultId, _assetAddress, _is1155, _allowAllItems);
                        setVaultFeatures(true /*enableMint*/, true /*enableRandomRedeem*/, true /*enableTargetRedeem*/, true /*enableRandomSwap*/, true /*enableTargetSwap*/);
                    }
            </code>
        </pre>
        <br>
        <p><b>6- Choose Wisely the type of data to store on-chain</b></p><br>

        <p>
            When deciding what data to store on-chain, you need to consider factors such as data size, security, and efficiency. 
            Here's a comparison of storing data as bytes, strings, or hashes:
        </p>
        <ul>
            <li>Bytes:</li>
            <p>- Storing data as bytes allows you to handle arbitrary binary data.</p>
            <p>- It is more efficient than strings for storing raw data, such as IPFS hashes or encrypted data.</p>
            <p>- Use bytes when you need to handle raw binary information or when the data format is not known in advance.</p>
            <p>- It provides flexibility but can result in higher storage costs and gas consumption, especially for large amounts of data.</p>

            <li>Strings:</li>
            <p>- Strings are convenient for readability and handling textual data, but they come with higher storage and gas costs compared to bytes.</p>
            <p>- If the data contains variable-length or frequently changing text, consider the gas cost implications.</p>

            <li>Hashes:</li>
            <p>- Storing the hash of information instead of the actual data can be beneficial for certain scenarios.</p>
            <p>- Hashes are fixed-size, regardless of the original data size, resulting in lower storage costs and efficient comparison of data integrity.</p>
        </ul>
        <br>
        <p><b>7- Consider passing Admin functions cost to user functions</b></p><br>
        <p>
            There a significant number of contracts that require access control mechanism in place to prevent unauthorized use of 
            some of its' functions which will increase the total gas cost of deploying & running the contract. One get away is to pass 
            this cost to the end user instead of paying it ourselves or the admin of the contract, let's take a look into some EIPs that 
            increase gas cost:
        </p>
        <p>
            First we have to differentiate between accounts haven't been accessed during a transaction; called Cold Accounts and 
            accounts have been accessed; called Warn accounts.
            <img alt="" src="https://miro.medium.com/1*anejceRNWAcdyL8XINvBUQ.png" />
        </p>

        
        <pre class="code-block">
            <code class="language-solidity">
                // This example will cost us 22,100 gas each time our admin adds a user
                contract AdminCostExample {

                    mapping(address => bool) private authorized;
                  
                    function addUser(address user) public onlyAdmin {
                      authorized[user] = true;
                    }
                }
            </code>
        </pre>

        <p>
            Due to the high cost of adding access list, reading cost each time from storage, and the reduced refund EIPs a great 
            alternative is authorizing users or whitelist them in our server, and pass the cost to the enduser as follows:
        </p>
        <pre class="code-block">
            <code class="language-solidity">
                // here instead of pilling up gas each time we want to add user, it is passed to end user
                contract UserAuthExample {
                    function mint(uint256 amount, uint8 v, bytes32 r, bytes32 s) public {
                      bytes32 hash = keccak256(abi.encodePacked(amount, msg.sender));
                      address signer = ecrecover(hash, v, r, s);
                      require(signer == user, 'unauthorized user');
                    }
                }
            </code>
        </pre>


        <p><b>8- Events are cheaper to store data but you should look out for cost</b></p><br>
        <p>
            Use events to store data on-chain but keep in mind that you can't access or use these data on-chain. Events are great tool for:
            <p>
                - Decentralized Communication: Logs can act as a communication mechanism between smart contracts and external systems. 
                By emitting events, smart contracts can notify other contracts or off-chain systems about specific occurrences or state changes.
            </p>
            <p>
                - Audit Trail: Logs provide a historical record of important events or transactions within a smart contract. 
                They can be used for accountability, transparency, and debugging purposes.
            </p>
            <p>
                - Off-chain Analysis: Logs can be retrieved and analyzed off-chain by external systems or tools. This allows for data extraction, 
                monitoring, and reporting without requiring direct access to the smart contract's state.
            </p>
        </p>

        <p>
            Logs do not directly affect the state of the blockchain or consume excessive gas. However, emitting logs incurs a certain gas cost, 
            which is paid by the contract owner. The cost depends on the number of topics and the data size emitted in the log, here is a 
            breakdown for cost incurred by emitting an event:
        </p>

        <pre class="code-block">
            <code class="language-solidity">
                event Add(uint256 value);

                function addValue(uint256 _value) external {
                emit Add(_value);
                }
            </code>
        </pre>
    
        <p>- Log Operation Base Gas Cost : 375 gas</p>
        <p>- Log Operation Data Byte Gas Cost : 8 gas/ byte x 32 bytes = 2256 gas</p>
        <p>- Log Operation Topic Gas Cost : 375 gas/topic x 1 topic = 375 gas</p>
        <p>- Memory Expansion Gas Cost : number of bytes x 3 gas/byte</p>
        <p>- Worth noting in the example above that we only stored one topic which is <code>value</code>, all costs are approximate and no indexed topic was stored.</p>
        <br>

        <p><b>9- Downsize Your Contract to Fight Size Limitation</b></p><br>
        <p>
            <a href="https://eips.ethereum.org/EIPS/eip-170">EIP-170</a> 
            forced a maximum limit of 24576 bytes for a contract, you may receive a warning indicating that it may not be deployable on the Mainnet. 
            This size limit was introduced to mitigate the risk of denial-of-service attacks, here's how to compact the size limitation:
        </p>

        <ul>
            <li><b>Consider visibility for functions and variables</b></li>
        </ul>
        
        <p>Public variables autogenerate getter functions, if you don't need these functions consider making your variables private.</p>
        <p>Public functions when called it copied all its parameters again to memory automatically, while external function's parameters are 
            not copied into memory but are read from calldata directly.
        </p>
        
        <p>— If your functions expected to be called from outside the contract, consider making them external. 
         - If your functions expected to be called within the contract only, consider making them private. 
         - If your functions expected to be called by inherited contracts, consider making them internal.
        </p>
        
        <ul>
            <li><b>Separate your contracts</b></li>
        </ul>
        
        <p>Separating logic into smaller contracts is considered a good architectural practice. When designing your contracts, 
            it's essential to analyze whether your functions belong together or if you can split the storage and functionality.
        </p>
        
        <p>By separating logic into smaller contracts, you can achieve several benefits. First, it enhances code readability and maintainability, 
            making it easier to understand and modify specific functionalities. It also promotes reusability, as smaller contracts with 
            well-defined responsibilities can be reused in different contexts.
        </p>
        
        <p>To determine if your functions belong together, you should consider their relatedness and the degree to which they share common state 
            variables or dependencies. If multiple functions consistently operate on the same set of data or require shared resources, it might 
            be appropriate to group them together in a single contract. On the other hand, if there are independent functionalities or 
            functionalities that operate on separate data or dependencies, splitting them into separate contracts can improve modularity and 
            flexibility.
        </p>
        
        <ul>
            <li><b>Use Proxy Patterns for mass deployment</b></li>
        </ul>
        
        <p>is a powerful technique to achieve efficient and scalable mass deployment of contracts. Instead of deploying individual 
            instances of the contract, you deploy a single implementation contract and multiple proxy contracts.
            The proxy contracts act as intermediaries that delegate their logic to the shared implementation contract. 
            Each proxy contract can have its own set of data, allowing for differentiation while sharing the same underlying logic.
        </p>
        
        <ul>
            <li><b>Libraries</b></li>
        </ul>
        
        <p>A straightforward approach to separate functionality code from storage is by utilizing libraries. 
            You can keep the storage and functionality in separate contracts. It's important to note that if you declare 
            library functions as internal, they will be directly added to the main contract during compilation. 
            However, by declaring them as public functions, they will be implemented in a separate library contract.
        </p>
        
        <p>To enhance the convenience of working with libraries, consider utilizing the "using for" keyword. 
            This keyword allows you to extend the functionality of a specific data type by attaching a library to it. 
            This way, you can conveniently access the library functions directly on the data type itself.
        </p>
        
        <ul>
            
            <li><b>Unused functions</b></li>
        </ul>
        
        <p>Removing unused internal or private functions will have no impact on the contract size, 
            but removing unused public or external functions will result in a smaller contract size. 
            Often times we add a lot of view functions for convenience reasons. 
            That's perfectly fine until you hit the size limit. Then you might want to really think about 
            removing all but absolutely essential ones.
        </p>
        
        <ul>
            <li><b>Error Handling</b></li>
        </ul>
            
        <p>There are four different ways to handle error messages displayed to end user, and here's the guide of how & when to utilize each:</p>
        <p><i><b>Assert:</b></i> 
        <p>- Should only be used to test for internal errors and to check invariants.</p>
        <p>- The <code>Assert</code> function creates an error of type <code>Panic(uint256)</code></p>
        <p>- The error code supplied with the error data indicates the kind of panic:</p>
            
        
        
        <ol style="color: #f8f8f8;">
            <li>0x00: Used for generic compiler inserted panics.</li><br>
            <li>0x01: If you call <code>assert</code> with an argument that evaluates to false.</li><br>
            <li>0x11: If an arithmetic operation results in underflow or overflow outside of an <code>unchecked { ... }</code> block.</li><br>
            <li>0x12; If you divide or modulo by zero (e.g. <code>5 / 0</code> or <code>23 % 0</code>).</li><br>
            <li>0x21: If you convert a value that is too big or negative into an enum type.</li><br>
            <li>0x22: If you access a storage byte array that is incorrectly encoded.</li><br>
            <li>0x31: If you call <code>.pop()</code> on an empty array.</li><br>
            <li>
                0x32: If you access an array, <code>bytesN</code> or an array slice at an out-of-bounds or negative index (i.e. <code>x[i]</code> 
                where <code>i >= x.length</code> or <code>i < 0</code>).
            </li><br>
            <li>0x41: If you allocate too much memory or create an array that is too large.</li><br>
            <li>0x51: If you call a zero-initialized variable of internal function type.</li>
        </ol>
        
        <p><i><b>Require</b></i> 
        <p>- Creates an error without any data or an error of type <code>Error(string)</code>.</p>
        <p>- It should be used to ensure valid conditions that can't be detected until execution time.</p>
        <p>- This includes conditions on inputs or return values from calls to external contracts.</p>
        <p>- You should shorten your error message so it would fit into 32 bytes or less.</p>
        <p>- You should consider using the same require message in multiple places.</p>
            
    

        <pre class="code-block">
            <code class="language-solidity">
                contract AssertAndRequireExample{

                    function sendHalf(address payable addr) public payable returns (uint balance) {
                        require(msg.value % 2 == 0, "Even value required.");
                        uint balanceBeforeTransfer = address(this).balance;
                        addr.transfer(msg.value / 2);
                
                        // Since transfer throws an exception on failure and
                        // cannot call back here, there should be no way for us to
                        // still have half of the Ether.
                        assert(address(this).balance == balanceBeforeTransfer - msg.value / 2);
                        return address(this).balance;
                    }
                }
            </code>
        </pre>

        <pre class="code-block">
            <code class="language-solidity">
                // Example from OZ using the same require in multiple places
                contract ERC721 {

                    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
                          _requireMinted(tokenId);
                  
                          string memory baseURI = _baseURI();
                          return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
                      }
                  
                     function getApproved(uint256 tokenId) public view virtual override returns (address) {
                          _requireMinted(tokenId);
                  
                          return _tokenApprovals[tokenId];
                      }
                  
                    function _requireMinted(uint256 tokenId) internal view virtual {
                          require(_exists(tokenId), "ERC721: invalid token ID");
                      }
                  }
            </code>
        </pre>

        <p><i><b>Revert with Custom Error</b></i> 
        <p>- A direct revert can be triggered using the <code>revert</code> statement.</p>
        <p>- The revert statement uses a parentheses which can either be empty, or includes a description, or number of arguments.</p>
        <p>- Empty revert and revert with arguments are more gas efficient if your contract have to check numerous conditions, as require & revert with the error message will cost more gas.</p>
            

        <pre class="code-block">
            <code class="language-solidity">
                contract CustomErrorExample {

                    // revert with arguments example
                    error ExceedsBalance(uint256 balance, uint256 decrementAmount);
                    // empty revert example
                    error NonExistAddress();
                  
                    function decrementAllowance(address minter, uint256 decrease) public {
                      
                          uint256 currentAllowance = mintAllowances[minter];
                          if(currentAllowance >= decrease) {
                              uint256 allowance = currentAllowance - decrease;
                              mintAllowances[minter] = allowance;
                              emit AllowanceDecreased(_msgSender(), minter, decrease, allowance);
                          } else {
                              revert ExceedsBalance(currentAllowance, decrease);
                          }
                      }
                  
                    function _notMinter(address minter) private view {
                          if(!isAssignee(minter)) {
                              revert NonExistAddress();
                          }
                     }
                    
                    // revert with description message as same as require
                    function buy(uint amount) public payable {
                          if (amount > msg.value / 2 ether)
                              revert("Not enough Ether provided.");
                          // Alternative way to do it:
                          require(
                              amount <= msg.value / 2 ether,
                              "Not enough Ether provided."
                          );
                          // Perform the purchase.
                      }
                    
                  }
            </code>
        </pre>

        <p><i><b>Try and Catch</b></i></p>
        <p>- The <code>try</code> and <code>catch</code> statements are used to handle exceptions that occur during execution.</p>
        <p>- The <code>try</code> statement is used to wrap the code that may throw an exception, while the <code>catch</code> statement is used to handle the exception.</p>
        <p>- The <code>try</code> statement can be followed by one or more <code>catch</code> statements to handle different types of exceptions.</p>
        <p>- The <code>catch</code> statement can include a variable to store the exception information, such as the error message or error code.</p>
        <p>- The <code>try</code> and <code>catch</code> statements are useful for handling exceptions that may occur during contract execution, such as invalid inputs or unexpected conditions.</p>
        <p>- The <code>try</code> and <code>catch</code> statements can help improve the robustness and reliability of your smart contract by providing a mechanism to handle errors gracefully.</p>
        <p>- - A failure in an external call can be caught using a try/catch statement, as follows:</p>

        <pre class="code-block">
            <code class="language-solidity">
                contract TryAndCatchExample {

                    DataFeed feed;
                    uint errorCount;
                
                    function rate(address token) public returns (uint value, bool success) {
                        // Permanently disable the mechanism if there are
                        // more than 10 errors.
                        require(errorCount < 10);
                        try feed.getData(token) returns (uint v) {
                            return (v, true);
                        } catch Error(string memory /*reason*/) {
                            // This is executed in case
                            // revert was called inside getData
                            // and a reason string was provided.
                            errorCount++;
                            return (0, false);
                        } catch Panic(uint /*errorCode*/) {
                            // This is executed in case of a panic,
                            // i.e. a serious error like division by zero
                            // or overflow. The error code can be used
                            // to determine the kind of error.
                            errorCount++;
                            return (0, false);
                        } catch (bytes memory /*lowLevelData*/) {
                            // This is executed in case revert() was used.
                            errorCount++;
                            return (0, false);
                        }
                    }
                }
            </code>
        </pre>

        <ul>
            <li>Function Modifiers</li>
        </ul>
        <p>
            Modifier variables share the same restricted stack with the they are added to and they add to the bytecode size of the contract, 
            so when modifiers are used intensely they could have a significant impact on the contract size.
        </p>
        
        <p>
            Internal functions, on the other hand, are not inlined but called as separate functions. This means they are very slightly more 
            expensive in run time but save a lot of redundant bytecode in deployment. Internal functions can also help avoid the dreaded 
            "Stack too deep Error" as variables created in an internal function don't share the same restricted stack with the original function.
        </p>

        <ul>
            <li>Consider using Mappings than Arrays</li>
        </ul>

        <p>
            Mappings are generally more cost-effective than arrays in Solidity, but there are some important considerations to keep in mind.
        </p>
        <p>
            Unlike arrays, mappings in Solidity are stored more efficiently in memory due to how the Ethereum Virtual Machine (EVM) works. 
            Arrays are not stored sequentially, but mappings are, which leads to cost savings. However, it's worth noting that arrays can be packed, 
            allowing for efficient storage of smaller elements like uint8 when they can be grouped together. In such cases, using arrays can be more 
            economical.
        </p>

        <p>
            Another aspect to consider is that mappings lack certain functionalities. For instance, you cannot obtain the length of a mapping or 
            iterate through all its elements as you would with an array. Consequently, depending on your specific use case, you might be compelled 
            to use an array despite the potentially higher gas cost.
        </p>

        <blockquote style="margin: 20px; padding-left: 10px; border-left: 5px solid #c4d59a;">
            <p>
                In summary, while mappings are generally cheaper to use than arrays in terms of gas consumption, 
                the decision between the two depends on factors such as the size of the elements and the desired functionality. 
                Careful consideration of these factors will help you determine the most efficient choice for your Solidity code.
            </p>

        </blockquote>
        <br>

        <p><b>10- Utilize Optimizer</b></p>

        <p>
            To maximize the efficiency of your Solidity smart contracts, it is crucial to leverage the optimizer provided by the solc compiler.
             The optimizer performs a range of optimizations on your code, such as removing redundant operations and minimizing storage usage.
        </p>
        
        <p>
            By default, the optimizer is enabled, but you can further customize its behavior. One important parameter to consider is 
            the number of optimizer runs. This value reflects the expected frequency of function calls within your contract. 
            For contracts that are used infrequently or expect less function calls, setting the runs value to 1 can result in the smallest 
            bytecode size, although function calls may incur slightly higher gas costs.
        </p>
        
        <p>
            On the other hand, contracts that are heavily utilized, such as transfer in ERC20, can benefit from setting a higher runs value, 
            resulting in slightly larger initial bytecode but reducing gas costs for frequent function calls.
        </p>

        <blockquote style="margin: 20px; padding-left: 10px; border-left: 5px solid #c4d59a;">
            <p>
                It is essential to strike the right balance by tailoring the optimizer runs parameter based on your contract's 
                usage patterns to achieve optimal gas efficiency and bytecode size.
            </p>
        </blockquote>
        

    </div>

    <form name="subscribe-form" method="POST" data-netlify="true" netlify-honeypot="bot-field" hidden>
        <input type="hidden" name="form-name" value="subscribe-form">
        <input type="text" name="bot-field">
        <input type="email" name="email">
    </form>

    <div class="modal-overlay" data-subscribe-modal hidden>
        <div class="modal-window" role="dialog" aria-modal="true" aria-labelledby="subscribeModalTitle">
            <button type="button" class="modal-close" data-close-subscribe aria-label="Close subscribe dialog">&times;</button>
            <h3 id="subscribeModalTitle" class="modal-title">Receive new articles directly in your inbox</h3>
            <form class="modal-form" data-subscribe-form>
                <label class="visually-hidden" for="subscribe-email">Email</label>
                <input type="email" id="subscribe-email" name="email" placeholder="enter your email" autocomplete="email" required>
                <span class="input-hint" data-subscribe-hint></span>
                <button type="submit" class="modal-submit" data-subscribe-submit disabled>subscribe</button>
                <p class="submit-feedback" data-subscribe-feedback role="status" aria-live="polite"></p>
            </form>
        </div>
    </div>

    <div class="modal-overlay" data-connect-modal hidden>
        <div class="modal-window modal-window--wallet" role="dialog" aria-modal="true" aria-labelledby="walletModalTitle" id="walletModal">
            <button type="button" class="modal-close" data-close-connect aria-label="Close wallet dialog">&times;</button>
            <h3 id="walletModalTitle" class="modal-title">Connect your wallet</h3>
            <p class="modal-intro">Select a wallet provider to continue. (Wallet integration coming soon.)</p>
            <ul class="wallet-list">
                <li><button type="button" class="wallet-button" data-wallet="metamask">MetaMask</button></li>
                <li><button type="button" class="wallet-button" data-wallet="coinbase">Coinbase Wallet</button></li>
                <li><button type="button" class="wallet-button" data-wallet="trust">Trust Wallet</button></li>
                <li><button type="button" class="wallet-button" data-wallet="phantom">Phantom</button></li>
                <li><button type="button" class="wallet-button" data-wallet="rainbow">Rainbow</button></li>
                <li><button type="button" class="wallet-button" data-wallet="ledger">Ledger Live</button></li>
            </ul>
            <p class="wallet-placeholder-note">Connection support will arrive soon. For now, this list is a visual placeholder.</p>
        </div>
    </div>

    <footer>
        <div class="footer-content">
            <p>&copy; 2025 Sasha Flores. All Rights Reserved.</p>
            <div class="social-links">
                <a href="https://www.linkedin.com/in/sflores369/" target="_blank"><ion-icon
                        name="logo-linkedin"></ion-icon></a>
                <a href="https://discord.com/users/827160247428710422" target="_blank"><ion-icon
                        name="logo-discord"></ion-icon></a>
                <a href="https://github.com/SashaFlores" target="_blank"><ion-icon name="logo-github"></ion-icon></a>
                <a href="https://www.youtube.com/@web3securityengineer" target="_blank"><ion-icon
                        name="videocam-sharp"></ion-icon><span class="tooltip"></span></a>
                <!-- <a href="https://drive.google.com/file/d/126pcD_XZmZIKTWTNyxdWUUqjOIYt7uWk/view?usp=sharing" target="_blank"><ion-icon name="cloud-download-outline"></ion-icon></a> -->
            </div>
        </div>
    </footer>

    <script src="../../js/bootstrap.bundle.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="../../js/aos.js"></script>
    <script src="../../js/custom.js"></script>
    <script src="../../js/post-slugs.js" defer></script>
    <script>
      window.POST_STATS_API_BASE = 'https://sashaflores-portfolio.vercel.app';
    </script>
    <script src="../../js/post-stats.js" defer></script>
    <script src="../../js/nav-cta.js" defer></script>

    <script type="module" src="https://unpkg.com/ionicons@latest/dist/ionicons/ionicons.esm.js"></script>
    <script nomodule="" src="https://unpkg.com/ionicons@latest/dist/ionicons/ionicons.js"></script>

</body>

</html>
