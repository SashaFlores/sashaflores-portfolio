<html lang="en"><head><title>EIP-712: Typed Structured Data.</title><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width initial-scale=1.0"><meta name="description" content="This is the second article illustrating hashing and signing typed structured data, the first article discussed key generation and message…"><meta name="keywords" content="eip-712, structured-data, ethsign, blockchain, ethereum"><meta name="author" content="Sasha Flores"><meta property="og:type" content="website"><meta property="og:title" content="EIP-712: Typed Structured Data."><meta property="og:description" content="This is the second article illustrating hashing and signing typed structured data, the first article discussed key generation and message…"><meta property="og:image" content="https://miro.medium.com/1*EpKtUG4ZQaEIvI1o486a2w.gif"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="EIP-712: Typed Structured Data."><meta property="twitter:description" content="This is the second article illustrating hashing and signing typed structured data, the first article discussed key generation and message…"><meta property="twitter:image" content="https://miro.medium.com/1*EpKtUG4ZQaEIvI1o486a2w.gif"></head><body><div class="blog"><h1 id="2c77">EIP-712: Typed Structured Data.</h1><img alt="" src="https://miro.medium.com/1*EpKtUG4ZQaEIvI1o486a2w.gif" /><p><i>This is the second article illustrating hashing and signing typed structured data, <a href="https://medium.com/@sasha-flores/public-private-keys-generation-signature-verification-using-ecdsa-algorithm-51cb4f656257">the first article</a> discussed key generation and message hashing and signing..</i></p><h3 id="02ec">EIP-712 is a standard for secure off-chain signature verification.</h3><p>It is the procedure for hashing and signing typed structured data as opposed to strings, it encodes function data similar to & compatible with solidity structs, and it depends on two other EIPs:</p><ul><li>EIP191 version <code>0x01</code> which was briefly mentioned in the previous article. Unlike the two other versions, this structured data version doesn't start with <code>0x19</code> because it is indeed a RLP-structure, but it is still in-compliant with EIP-191 by including the ‘version byte` fixed to <code>0x01</code></li></ul><img alt="first article -purpose of `0x19`" src="https://miro.medium.com/1*3ofsjZEH52oOGpgT_-6_yg.png" /><ul><li><a href="https://eips.ethereum.org/EIPS/eip-155">EIP155</a>: introduce chain Id as one of the encoded transaction parameters so instead of hashing only six RLP encoded transaction parameters we should hash nine (as shown below).
- chain Id is used to calculate v value.
- the proposal still supports both signature scheme so it's up to the developer to use the old signature scheme where v = 27 and v = 28 or the updated signature scheme where chain Id is part of v value.</li></ul><script src="https://gist.github.com/SashaFlores/2585b879942977f2589f17db4a2fd55b.js"></script><p><i>If block.number ≥ FORK_BLKNUM & Chain Id is available, then computing the transaction hash should hash nine RLP encoded parameters. If you do, then the v of the signature MUST include chain Id as shown in table.</i></p><p><b><a href="https://eips.ethereum.org/EIPS/eip-712">EIP712</a>:</b></p><p>This proposal aims to improve the usability of off-chain message signing for use on-chain. We are seeing growing adoption of off-chain message signing as it saves gas and reduces the number of transactions on the blockchain.</p><p><b>Q: What is the acceptable typed structured data?</b></p><p>It accepts data like it does with struct in solidity where the struct has a name as an identifier that contains zero or several member variables; each member variable has a type and a name. The type can be either an atomic type, a dynamic type, or a reference type as shown in table below:</p><script src="https://gist.github.com/SashaFlores/cd97bc47b6bad106ddcf689bcde4d22a.js"></script><p>Basically we're defining the struct that will be used in any transaction & specify their types, let's take <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/ERC20Permit.sol">ERC20Permit </a>as an example & walk through how the data is structured:</p><pre><code>/**
 * `Permit` is the struct identifier name.
 * - `address` is the atomic type of named `owner`.
 * - `uint256` is the atomic type of named `spender`.
 * - `uint256` is the atomic type of named `value`.
 * - `uint256` is the atomic type of the randomly 
 *    generated value during the signing process named `nonce`.
 * - `uint256` is the atomic type of named `deadline`
 */
struct Permit {
    address owner;
    address spender;
    uint256 value;
    uint256 nonce;
    uint256 deadline;
}</code></pre><p>So the identifier name of the struct, type of each element and its value are what the proposal use to build its components which are:</p><p><b>1- Hash Struct</b></p><p>— from it's name; it is hashing the struct.
 -hashing the struct consists of hashing two components:
<code>hashStruct = keccak256(typeHash ‖ encodeData(s))</code></p><ul><li><code>typeHash</code> : 
- is the process of hashing the encoded type of struct where each member is written as type & name.
- is a constant for a given struct type & doesn't need to be runtime computed.
<code>typeHash = keccak256(encodeType(typeOf(s)))</code></li></ul><pre><code>/**
 * Hashing the struct name, where each memeber has a type & name in 
 * a constant variable `_PERMIT_TYPEHASH` which is fixed at compile-time
 * - `Permit` struct identifier name.
 * - `address` is the type of `owner` name.
 * - `address` is the type of `spender` name.
 * - `uint256` is the type of `value` name.
 * - `uint256` is the type of `nonce` name.
 * - `uint256` is the type of `deadline` name.
 */
bytes32 private constant _PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)")</code></pre><ul><li><code>encodeData</code> : 
- is the process of encoding the struct instance.
- it concatenates all encoded member values in the order they appear in the type, where each member value is 32 bytes long.</li></ul><pre><code>// `permit` function which instantiate `Permit` struct.
function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public virtual override {
        require(block.timestamp <= deadline, "ERC20Permit: expired deadline");
        /**
         * encode the type of struct Hash `_PERMIT_TYPEHASH'
         * enode the struct instance in the order they appear as follows:
         * - `owner`, `spender`, `value`, `nonce`, & `deadline`
         * finally hash the set of structurced typed data containing all 
         * the instances of all the strcut types 
         */
        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));

   
        bytes32 hash = _hashTypedDataV4(structHash);

        address signer = ECDSA.recover(hash, v, r, s);
        require(signer == owner, "ERC20Permit: invalid signature");

        _approve(owner, spender, value);
    }</code></pre><p>Q: How different types are encoded in the EVM?</p><script src="https://gist.github.com/SashaFlores/fd7619c744ad28f678e0b80c7eee8494.js"></script><p><b>2- Domain Separator</b></p><p><code>domainSperator = hashStruct(eip712Domain)</code></p><ul><li>is the process of hashing domain information to be used as a domain separator.</li><li>it's designed to separate between two different domains that may have identical data structure to avoid validating same signatures for both.</li><li>where the type of <code>eip712Domain</code> is a struct named <code>EIP712Domain.</code></li><li>by default in OZ, all fields below are included but developers can include or skip only the fields that make sense for their signing domain.</li><li>It's important to preserve the order as shown below, skipping any absent fields if any.</li></ul><pre><code class="language-csharp">struct EIP712Domain {
    string name;    // name of the DApp 
    string version; // current version of the signing domain
    uint256 chainId; // EIP-155 chain id
    address verifyingContract;  // address of contract verifying signature
    bytes32 salt;   // domain separtor
}</code></pre><p>This is already build and coded in <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/EIP712.sol">EIP712.sol </a>from OZ so if you are inheriting the contract you don't need to do anything, but to follow the example:</p><p><i><b>First:</b></i></p><p>we will hash all type values in struct and make it constant to be computed at compile-time as follows:</p><pre><code>bytes32 private constant _TYPE_HASH = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)")</code></pre><blockquote class="small"><p>Note: be careful with the order of the types to be exactly the same as struct & no spaces after each comma.</p></blockquote><p><i><b>Second:</b></i></p><p>In your contract constructor you will input your DApp or Protocol name and version, but under the hood the following is happening:</p><ul><li>the name will be hashed: <code>keccak256(bytes(name))</code></li><li>the version will be hashed: <code>keccak256(bytes(version))</code></li><li>and the domain separator will be equal to: <code>function domainSeparator() public view returns(bytes32) {
return keccak256(abi.encode(_TYPE_HASH, hashedName, hashedVersion, block.chainid, address(this)))</code></li></ul><p><b>Customize Signing Domain Example:</b></p><p>In case you want to customize the EIP-712 and code it yourself, as an example we will have the name of the protocol as a constant since it will not change during it's life time:</p><pre><code>// optional 
string public constant NAME = 'dapp name';


bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH = keccak256(EIP712Domain(string version,uint256 chainId,address verifyingContract));


/**
 * domainSeparator = hashStruct(eip712Domain).
 * - `DOMAIN_SEPARATOR_TYPEHASH`: keccack256 hashing `typeHash`
 * - `keccak256(bytes(version))`: Dynamic data type hashing of string
 * - `block.chainid` & `address(this)`: Atomic data type hashing of uint256 & address.
 */
function domainSeparator() public view returns(bytes32) {
    return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, keccak256(bytes(version)), block.chainid, address(this)))
}</code></pre><p><b>Signing Typed Structured Data</b></p><p><code>eth_signTypedData</code> is similar to <code>eth_sign</code> method with 2 parameters:</p><ul><li>Address of the account signing transaction.</li><li>Typed structured data to sign.</li></ul><p>Typed data is a JSON object that contains type information, domain separator, and the message object which will be displayed to signer as:</p><img alt="" src="https://miro.medium.com/1*Dw0MU2IC9ZgjsJ2EoWs8PQ.png" /><p>which will returns a 65 bytes signature as in <code>eth_sign</code> with the same parameters of r & s each equals 32 bytes and v of 1 byte that includes the chain id.</p><p>If the signing address is an Externally Owned Account (EOA) then <code>ecrecover</code>is used to verify that the public key matches the key that generates the signature. Further restrictions can be specified like the signer is the owner of the contract as in ERC20Permit.</p><p>That will lead us to the next article that will answer the question, what if the signing account isn't an EOA but another smart contract.</p></div></body></html>