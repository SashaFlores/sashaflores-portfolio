<html lang="en"><head><title>Public-Private Keys Generation & Signature Verification using ECDSA Algorithm.</title><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width initial-scale=1.0"><meta name="description" content="Note: This will be series of articles to break down the concept of cryptographic keys and how they are used to sign messages, typed…"><meta name="keywords" content="ecdsa, ethereum-blockchain, signature, cryptography"><meta name="author" content="Sasha Flores"><meta property="og:type" content="website"><meta property="og:title" content="Public-Private Keys Generation & Signature Verification using ECDSA Algorithm."><meta property="og:description" content="Note: This will be series of articles to break down the concept of cryptographic keys and how they are used to sign messages, typed…"><meta property="og:image" content="https://miro.medium.com/1*wMYUen1G4wREgq7U6A7vcA.gif"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="Public-Private Keys Generation & Signature Verification using ECDSA Algorithm."><meta property="twitter:description" content="Note: This will be series of articles to break down the concept of cryptographic keys and how they are used to sign messages, typed…"><meta property="twitter:image" content="https://miro.medium.com/1*wMYUen1G4wREgq7U6A7vcA.gif"></head><body><div class="blog"><img alt="" src="https://miro.medium.com/1*wMYUen1G4wREgq7U6A7vcA.gif" /><h1 id="c1f9">Public-Private Keys Generation & Signature Verification using ECDSA Algorithm.</h1><p><i>Note: This will be series of articles to break down the concept of cryptographic keys and how they are used to sign messages, typed structured data and to verify signatures.</i></p><p>Elliptic Curve Digital Signature Algorithm (ECDSA) is a asymmetric cryptography that is widely used to secure electronic transactions. ECDSA is based on the concept of elliptic curve cryptography, which involves using points on a curve over a finite field to generate cryptographic keys.</p><p>The concept of public and private keys is at the heart of asymmetric cryptography and to understand how ECDSA works, it is important to first understand the concepts of private and public keys in public-key cryptography.</p><p>To generate the public and private keys for ECDSA, we first select an elliptic curve and a point on that curve called the generator(also known as the base point). The private key is then a random number between 1 and the order of the generator, while the public key is the result of multiplying the base point by the private key using elliptic curve multiplication.</p><p>The process of elliptic curve multiplication involves repeatedly adding the base point to itself (in a process called "doubling") and adding it to other points on the curve (in a process called "adding"). This process is similar to traditional modular arithmetic, but with a few key differences that make it more difficult to compute, so main parameters involved in generating keys are:</p><ul><li><b>G :</b> generator point which is used for scalar multiplication on the curve (multiply integer by EC point).</li><li><b>Order</b> <i><b>n:</b></i> of the subgroup of EC points, generated by <b>G</b>, which defines the length of the private keys (e.g. 256 bits)</li><li><b>Private Key:</b> is a randomly selected single positive integer; represented as a byte array of length 32 in the range of [0...<i><b>n</b></i>-1]</li><li><b>Public Key</b> (EC point) = Private Key * G</li></ul><img alt="An elliptic curve is a curve that is defined by an equation of the form y² = x³ + ax + b, where a and b are constants" src="https://miro.medium.com/1*yiox0cK7-BIKGzAC0qXKGQ.png" /><h3 id="cfd0">Q: what are Public-Private keys role in sending and signing messages?</h3><p>first we need to know different types of cryptographic signatures:</p><p><b>1- <code>eth_sign:</code></b> it used to be a signing method that allows signing an arbitrary hash, which means it can be used to sign transactions, or any other data, making it a dangerous phishing risk.</p><img alt="" src="https://miro.medium.com/1*RedEu-a6ZKHZFFa-YwIplw.png" /><p>But because the <a href="https://github.com/ethereum/go-ethereum/pull/2940">geth client </a>changed the behavior of their <code>eth_sign</code> method based on EIP-191 version <code>0x00</code>similar to <code>personal_sign</code>, It now accepts an arbitrary message, prepends a known message, hashes the result using keccak256 it calculates the signature of the hash (breaks backwards compatibility!).</p><ul><li>The known message added to the input before hashing is:<code>"\x19Ethereum Signed Message:\n" + len(message)</code>.</li><li>The full message (including the prefix) is then hashed again, and that data is signed: <code>sign(keccak256("\x19Ethereum Signed Message:\n" + len(message) + message)))</code>.</li></ul><p>By adding a prefix <code>0x19</code>to the message makes the calculated signature recognisable as an Ethereum specific signature. This prevents misuse where a malicious DApp can sign arbitrary data (e.g. transaction) and use the signature to impersonate the victim.</p><p><b>2- <code>eth_signTypedData_v4:</code></b> is based on <a href="https://eips.ethereum.org/EIPS/eip-712">EIP-712</a> version <code>0x01</code> and will be discussed in details in another article.</p><img alt="EIP-712" src="https://miro.medium.com/1*DnAEFKxU3ERNYaDUM0zmQg.png" /><p><b>3- <code>personal_sign:</code></b> is based on <a href="https://eips.ethereum.org/EIPS/eip-191">EIP-191</a> version <code>0x45</code> explained in details below this article.</p><img alt="personal_sign" src="https://miro.medium.com/1*0KrtuDuXkrqKrZbQM6nAUA.png" /><img alt="different types of available signatures" src="https://miro.medium.com/1*P5GYwTh9-MbK4Veio0wuWA.png" /><p><b>EIP-191: Signed Data Standard</b></p><p>It proposes a specification about how to handle signed data in Ethereum contracts, and it has three versions:</p><p>1- Version <code>0x00</code> : the format for <code>signed_data</code> as follows:</p><p><code>0x19 <1 byte version> <intended validator address> <data to sign></code></p><ul><li>0x19 : is intended to ensure that the <code>signed_data</code> is not one RLP-structure. Thus can't be an Ethereum transaction</li><li>1 byte version : which has the <code>0x00 version</code></li><li>intended validator address : which is the address with validation privileges for the version specific data ‘1 byte version'. Which can be the contract address in cases like Mutlisig wallets that perform an execution based on a passed signature.</li><li>data to sign : can be any arbitrary data.</li></ul><pre><code>    ECDSA library from OZ.
    /**
     * @dev Returns an Ethereum Signed Data with intended validator, created from a
     * `validator` and `data` according to the version 0 of EIP-191.
     *
     * See {recover}.
     */
    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked("\x19\x00", validator, data));
    }</code></pre><p>2- Version <code>0x001</code> : the format for structured data, which will be discussed in another article.</p><p>3- Version <code>0x45</code> : same semantics as <code>eth_sign</code> but also accepts the password of the account as last argument.
- The private key used to sign the hash is temporary unlocked in the scope of the request.
- The format for <code>personal_sign</code> as follows:</p><p><code>0x19 <0x45 (E)> <thereum Signed Message:\n" + len(message)> <data to sign></code></p><ul><li>0x19 : is intended to ensure that the <code>signed_data</code> is not one RLP-structure. Thus can't be an Ethereum transaction</li><li>0x45 (E) : is the version <code>0x45</code> (E) has the <code><thereum Signed Message:\n" + len(message)> for the version specific data.</code></li><li>data to sign : can be any arbitrary data.</li></ul><blockquote class="small"><p>NB: The <code>E</code> in <code>Ethereum Signed Message</code> refers to the version byte 0x45. The character <code>E</code> is <code>0x45</code> in hexadecimal which makes the remainder, <code>thereum Signed Message:\n + len(message)</code>, the version-specific data.</p></blockquote><p><i>Note: the ‘0x19' was originated from <code>\x18Bitcoin signed message:\n</code>, where <code>\x18</code> is a Bitcoin VarInt (for small numbers, it's just the same as the value) for 24, which is the length of the string <code>"Bitcoin signed message:\n"</code>. So, <code>\x19</code> is the Bitcoin VarInt for the length of the string `Ethereum signed message:\n".</i></p><p><i>As it turned out, <code>0x19</code> is a value that isn't a valid RLP encoded array, which is what all transactions are encoded as, and so EIP-191 was able to retcon it as the version byte.</i></p><p><i>Resource: you can practice all kinds of signatures using <a href="https://metamask.github.io/test-dapp/#personalSign">MetaMask Interactive</a> simulation. Just take into consideration allowing eth-sign from advanced settings & that MetaMask kept the old eth_sign method to support existing applications.</i></p><p>let's say Mike wants to send a message to Frank, to do so Mike will need:</p><ul><li>Frank's public key to encrypt the message.</li><li>The full hashed message including the prefix of 32 bytes length.</li><li>Mike sign the hashed message with his private key.</li><li>Frank will decrypt the received message with his private key if it matches his public that was used to encrypt the message.</li><li>If anyone else in the middle intercepts the data, they can't unlock, read, or otherwise interpret it without the corresponding private key.</li></ul><p>And that would relate to the below function from <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol#L165">ECDSA Library </a>from Open Zeppelin:</p><pre><code>function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {
        // 32 is the length in bytes of hash,
        // enforced by the type signature above
        /// @solidity memory-safe-assembly
        assembly {
            mstore(0x00, "\x19Ethereum Signed Message:\n32")
            mstore(0x1c, hash)
            message := keccak256(0x00, 0x3c)
        }
    }</code></pre><p>The breakdown of the function as follows:</p><ul><li>`mstore(0x00, "\019Ethereum Signed Message:\32")` => is telling the compiler to store the bytes of the prefix message in memory location <code>0x00</code>as the starting point for the message hash that is being created</li><li>`mstore(0x1c, hash)` => stores the original hash in memory location <code>0x1c</code>. The <code>0x1c</code> offset is used because the first 4 bytes (or 32 bits) of the memory are used for the Ethereum message prefix.</li><li><code>message := keccak256(0x00, 0x3c)</code> creates the message hash by applying the Keccak-256 hash function to the bytes stored in memory locations <code>0x00</code> through <code>0x3c</code> (a total of 64 bytes). This includes the Ethereum message prefix, followed by the original hash. The resulting hash is then assigned to the <code>message</code> variable and returned.</li></ul><p><b>Ethereum Signature using ECDSA</b></p><p>Signature consists of {r, s, v} which is 65 bytes long as follows:</p><ul><li>r : 32 bytes => is known as the "ephemeral random value". It is a randomly generated number used in the signing process to create a unique signature for each message.
 <b>r = k * G</b> 
G: is the generator 
K: is the random value of each signature(nonce)</li><li>s : 32 bytes => is referred to as the "pointer" because it is used to indicate the location of the <code>signatures</code> byte array; where the <code>r</code>, <code>s</code>, and <code>v</code> values for the current signature are stored.
signatures on Ethereum can be malleable or immalleable because <a href="https://eips.ethereum.org/EIPS/eip-2">EIP-2 </a>still allows both signatures, so it depends on the library developer used to generate signature.
If this possibility is eliminated, then the valid range for <code>s</code>is the lower half of the curve</li><li>v : one byte => is called the "identifier" because it is used to identify the signature generated. On the elliptic curve, there could be multiple points that represent <code>r</code> and <code>s</code> values either in the lower or the upper half of the curve and that's what make a signature malleable; the possibility of two different signatures thus two different public keys. That's why <code>v</code>is called the identifier because it eliminates one of these 2 possibilities.</li></ul><p>If signature is unique(immalleable) then the value for <code>v</code> is 27/28.</p><p>ECDSA library from Open Zeppelin in <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol#L124">tryRecover function</a> accepts only unique signatures with <code>s</code>in the lower half curve & <code>v</code>is 27 or 28 as follows:</p><pre><code>uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0</code></pre><ul><li>If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 as s1 and flip v from 27 to 28 or vice versa.</li><li>If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept these malleable signatures as well.</li></ul><p><b>ECDSA Sign:</b></p><p>The ECDSA signing algorithm takes as input a message hash + a private key and produces as output a <b>signature</b>, which consists of pair of integers {<i><b>r</b></i>, <i><b>s</b></i>} The <b>ECDSA signing</b> algorithm works as follows:</p><ul><li>Calculate the message <b>hash</b>, using a cryptographic hash function like SHA-256: <i><b>h</b></i> = hash(<i><b>msg)</b></i></li><li>Generate securely a <b>random</b> number <i><b>k</b></i> in the range [1..<i><b>n</b></i>-1], in case of <b>deterministic-ECDSA</b>, the value <i><b>k</b></i> is derived from <i><b>h</b></i> + <i><b>private Key</b></i></li><li>Calculate the random point r = <i><b>k</b></i> * <b>G</b></li><li>Calculate the signature proof: <b>s = k^-1(h + r * private key)</b></li></ul><p>The calculated <b>signature</b> {<i><b>r</b></i>, <i><b>s</b></i>} is a pair of integers, each in the range [1...<i><b>n</b></i>-1]. It encodes the random point r = <i><b>k</b></i> * <b>G</b>, along with a proof <i><b>s</b></i>, confirming that the signer knows the message <i><b>h</b></i> and the private key. The proof <i><b>s</b></i> is by idea verifiable using the corresponding <i><b>public Key</b></i>.</p><p><b>ECDSA Verify Signature</b></p><p>The algorithm to verify a ECDSA signature takes as input the signed message <i><b>msg</b></i> + the signature {<i><b>r</b></i>, <i><b>s</b></i>} produced from the signing algorithm + the public key, corresponding to the signer's private key. The output is boolean value: <i><b>valid</b></i> or <i><b>invalid</b></i> signature. The <b>ECDSA signature verify</b> algorithm works as follows:</p><ul><li>Calculate the message <b>hash</b>, with the same cryptographic hash function used during the signing: <i><b>h</b></i> = hash(<i><b>msg</b></i>)</li><li>Calculate the modular inverse of the signature proof: <i><b>s1</b></i> = s^-1</li><li>Recover the random point used during the signing: <i><b>r'</b></i> = (<i><b>h</b></i> * <b>s1</b>) * <b>G</b> + (<i><b>r</b></i> * <i><b>s1</b></i>) * <i><b>public Key</b></i></li><li>if the calculated r' == r generated during signing, then signature is valid.</li></ul><p>The general idea of the signature verification is to <b>recover the point</b> ‘<i><b>r'</b></i> using the public key and check whether it is same point r, generated randomly during the signing process.</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FvYwYe-Gv_XI%3Ffeature%3Doembed&display_name=YouTube&url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DvYwYe-Gv_XI&image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FvYwYe-Gv_XI%2Fhqdefault.jpg&key=a19fcc184b9711e1b4764040d3dc5c07&type=text%2Fhtml&schema=youtube" title="" height="480" width="854"></iframe><p>Below is the code snippet of the above tutorial used for signature verification:</p><pre><code class="language-csharp">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

/* Signature Verification

How to Sign and Verify
# Signing
1. Create message to sign
2. Hash the message
3. Sign the hash (off chain, keep your private key secret)

# Verify
1. Recreate hash from the original message
2. Recover signer from signature and hash
3. Compare recovered signer to claimed signer
*/

contract VerifySignature {
    /* 1. Unlock MetaMask account
    ethereum.enable()
    */

    /* 2. Get message hash to sign
    getMessageHash(
        0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C,
        123,
        "coffee and donuts",
        1
    )

    hash = "0xcf36ac4f97dc10d91fc2cbb20d718e94a8cbfe0f82eaedc6a4aa38946fb797cd"
    */
    function getMessageHash(
        address _to,
        uint _amount,
        string memory _message,
        uint _nonce
    ) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(_to, _amount, _message, _nonce));
    }

    /* 3. Sign message hash
    # using browser
    account = "copy paste account of signer here"
    ethereum.request({ method: "personal_sign", params: [account, hash]}).then(console.log)

    # using web3
    web3.personal.sign(hash, web3.eth.defaultAccount, console.log)

    Signature will be different for different accounts
    0x993dab3dd91f5c6dc28e17439be475478f5635c92a56e17e82349d3fb2f166196f466c0b4e0c146f285204f0dcb13e5ae67bc33f4b888ec32dfe0a063e8f3f781b
    */
    function getEthSignedMessageHash(
        bytes32 _messageHash
    ) public pure returns (bytes32) {
        /*
        Signature is produced by signing a keccak256 hash with the following format:
        "\x19Ethereum Signed Message\n" + len(msg) + msg
        */
        return
            keccak256(
                abi.encodePacked("\x19Ethereum Signed Message:\n32", _messageHash)
            );
    }

    /* 4. Verify signature
    signer = 0xB273216C05A8c0D4F0a4Dd0d7Bae1D2EfFE636dd
    to = 0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C
    amount = 123
    message = "coffee and donuts"
    nonce = 1
    signature =
        0x993dab3dd91f5c6dc28e17439be475478f5635c92a56e17e82349d3fb2f166196f466c0b4e0c146f285204f0dcb13e5ae67bc33f4b888ec32dfe0a063e8f3f781b
    */
    function verify(
        address _signer,
        address _to,
        uint _amount,
        string memory _message,
        uint _nonce,
        bytes memory signature
    ) public pure returns (bool) {
        bytes32 messageHash = getMessageHash(_to, _amount, _message, _nonce);
        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);

        return recoverSigner(ethSignedMessageHash, signature) == _signer;
    }

    function recoverSigner(
        bytes32 _ethSignedMessageHash,
        bytes memory _signature
    ) public pure returns (address) {
        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);

        return ecrecover(_ethSignedMessageHash, v, r, s);
    }

    function splitSignature(
        bytes memory sig
    ) public pure returns (bytes32 r, bytes32 s, uint8 v) {
        require(sig.length == 65, "invalid signature length");

        assembly {
            /*
            First 32 bytes stores the length of the signature

            add(sig, 32) = pointer of sig + 32
            effectively, skips first 32 bytes of signature

            mload(p) loads next 32 bytes starting at the memory address p into memory
            */

            // first 32 bytes, after the length prefix
            r := mload(add(sig, 32))
            // second 32 bytes
            s := mload(add(sig, 64))
            // final byte (first byte of the next 32 bytes)
            v := byte(0, mload(add(sig, 96)))
        }

        // implicitly return (r, s, v)
    }
}</code></pre><h2 id="db23">Q: Is it possible for anyone to reveal the private key if nonce used in signature is known?</h2><p>The answer is yes, even if your private key hasn't been breached & you kept it safe all the time. Since your public key is known on the blockchain & shareable and since the nonce generated when signing the message is known "which shouldn't" it's possible to crackdown the private key.</p><ul><li><b>public key = private key * G</b></li><li><b>r = k * G</b> <i>where k is the nonce</i></li><li><b>s = k^-1(message hash + r * private key)</b></li><li><b>s * k =</b> <b>message hash + r * private key</b></li><li><b>r * private key = s * k + message hash</b></li><li><b>private key = r^-1 * ((s * K) - message hash)</b></li></ul><p>It's extremely important that you don't store your nonce every time you sign a message or a transaction.</p><p>References:</p><ul><li>If you want to know more about cryptography and ECDSA, you can check out <a href="https://www.youtube.com/watch?v=RdP7_hMUTn0">Bill Buchanan YouTube</a></li><li><a href="https://github.com/ethereumbook/ethereumbook">Mastering Ethereum</a>, by Andreas M. Antonopoulos, Gavin Wood</li></ul></div></body></html>